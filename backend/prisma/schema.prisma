// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  MODERATOR
  BANNED
}

model PresenceEvent {
  id        String   @id @default(uuid())
  userId    String
  username  String
  clients   String[] // Array instead of comma-separated
  metadata  Json?    @db.JsonB // JSONB for flexible data
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([createdAt])
}

model TypingEvent {
  id        String   @id @default(uuid())
  userId    String
  username  String
  channelId String
  channel   String
  guildId   String
  metadata  Json?    @db.JsonB
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([guildId])
  @@index([channelId])
  @@index([createdAt])
}

model MessageEvent {
  id        String   @id @default(uuid())
  userId    String
  username  String
  channelId String
  channel   String
  guildId   String
  content   String   @db.Text
  metadata  Json?    @db.JsonB
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([guildId])
  @@index([channelId])
  @@index([createdAt])
  // Full-text search can be implemented using PostgreSQL's tsvector in a raw query or migration
}

model JoinEvent {
  id             String   @id @default(uuid())
  userId         String
  username       String
  guildId        String
  accountAgeDays Int
  metadata       Json?    @db.JsonB
  createdAt      DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([guildId])
  @@index([createdAt])
}

model DeletedMessageEvent {
  id        String   @id @default(uuid())
  userId    String
  username  String
  channelId String
  channel   String
  guildId   String
  metadata  Json?    @db.JsonB
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([guildId])
  @@index([channelId])
  @@index([createdAt])
}

model ReactionTime {
  id           String   @id @default(uuid())
  observerId   String
  observerName String
  actorId      String
  actorName    String
  channelId    String
  guildId      String
  deltaMs      Int
  metadata     Json?    @db.JsonB
  createdAt    DateTime @default(now()) @db.Timestamptz

  @@index([observerId])
  @@index([actorId])
  @@index([guildId])
  @@index([createdAt])
}

model RoleChangeEvent {
  id         String   @id @default(uuid())
  userId     String
  username   String
  guildId    String
  addedRoles String[] // Array instead of comma-separated
  metadata   Json?    @db.JsonB
  createdAt  DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([guildId])
  @@index([createdAt])
}

model BlockedIP {
  id        Int       @id @default(autoincrement())
  ip        String    @unique
  reason    String?
  expiresAt DateTime? @db.Timestamptz // Optional expiration time for temporary blocks
  createdAt DateTime  @default(now()) @db.Timestamptz

  @@index([ip])
  @@index([expiresAt])
}

model WhitelistedIP {
  id        Int      @id @default(autoincrement())
  ip        String   @unique
  reason    String?  // Why this IP is whitelisted (e.g., "Office IP", "Admin")
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([ip])
}

model BannedUser {
  id        Int      @id @default(autoincrement())
  userId    String   @unique
  username  String
  reason    String?
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
}

model User {
  id                   String   @id @default(cuid())
  discordId            String   @unique
  username             String
  discriminator        String
  avatar               String?
  email                String?
  locale               String?
  verified             Boolean
  ipAddress            String?
  userAgent            String?
  accessToken          String
  refreshToken         String
  refreshTokenIssuedAt DateTime @default(now()) @db.Timestamptz
  accessTokenExpiresAt DateTime @db.Timestamptz
  lastSeenAt           DateTime @db.Timestamptz
  createdAt            DateTime @default(now()) @db.Timestamptz
  updatedAt            DateTime @updatedAt @db.Timestamptz

  // New role field
  role Role @default(USER)

  guilds          Guild[]
  refreshTokens   RefreshToken[]
  sessions        Session[]
  apiKeys         ApiKey[]
  loginLogs       LoginLog[]
  deletionRequest DeletionRequest?
  consentLogs     ConsentLog[]

  @@index([discordId])
  @@index([email])
}

model Guild {
  id          String  @id @default(cuid())
  guildId     String  @unique
  name        String
  icon        String?
  owner       Boolean
  permissions BigInt
  userId      String
  user        User    @relation(fields: [userId], references: [id])
}

model Permission {
  id          String           @id @default(cuid())
  name        String           @unique // e.g., "analytics.view", "users.ban"
  description String
  category    String // e.g., "analytics", "admin"
  createdAt   DateTime         @default(now()) @db.Timestamptz
  updatedAt   DateTime         @updatedAt @db.Timestamptz
  roles       RolePermission[]

  @@index([category])
  @@index([name])
}

model RolePermission {
  role         Role
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now()) @db.Timestamptz

  @@id([role, permissionId])
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  familyId  String // For token rotation detection
  used      Boolean  @default(false)
  revoked   Boolean  @default(false)
  expiresAt DateTime @db.Timestamptz
  userAgent String?
  ipAddress String?
  createdAt DateTime @default(now()) @db.Timestamptz
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([familyId])
  @@index([token])
  @@index([expiresAt])
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  userAgent    String?
  ipAddress    String?
  lastActivity DateTime @default(now()) @db.Timestamptz
  expiresAt    DateTime @db.Timestamptz
  createdAt    DateTime @default(now()) @db.Timestamptz
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model ApiKey {
  id         String    @id @default(cuid())
  key        String    @unique
  name       String
  userId     String
  scopes     String // JSON array of scopes/permissions
  lastUsedAt DateTime? @db.Timestamptz
  expiresAt  DateTime? @db.Timestamptz
  revoked    Boolean   @default(false)
  createdAt  DateTime  @default(now()) @db.Timestamptz
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([key])
}

model LoginLog {
  id        String   @id @default(cuid())
  userId    String
  ipAddress String
  userAgent String?
  success   Boolean
  reason    String? // Failure reason if success=false
  createdAt DateTime @default(now()) @db.Timestamptz
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([ipAddress])
}

// GDPR Compliance Models

model DeletionRequest {
  id           String   @id @default(cuid())
  userId       String   @unique
  reason       String?
  requestedAt  DateTime @default(now()) @db.Timestamptz
  scheduledFor DateTime @db.Timestamptz
  status       String   @default("PENDING") // PENDING, CANCELLED, COMPLETED
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([scheduledFor])
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String // ACCOUNT_CREATED, DATA_EXPORTED, ACCOUNT_DELETED, etc.
  details   Json?    @db.JsonB
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@index([ipAddress])
}

model ConsentLog {
  id          String   @id @default(cuid())
  userId      String
  consentType String // PRIVACY_POLICY, COOKIES, DATA_COLLECTION
  granted     Boolean
  version     String // Policy version
  createdAt   DateTime @default(now()) @db.Timestamptz
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([consentType])
}

model DataRetentionPolicy {
  id            String    @id @default(cuid())
  dataType      String    @unique // PRESENCE_EVENTS, MESSAGE_EVENTS, TYPING_EVENTS, etc.
  retentionDays Int // Number of days to retain data
  description   String?
  enabled       Boolean   @default(true)
  lastCleanupAt DateTime? @db.Timestamptz
  createdAt     DateTime  @default(now()) @db.Timestamptz
  updatedAt     DateTime  @updatedAt @db.Timestamptz

  @@index([dataType])
  @@index([enabled])
}

model SecurityLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String // LOGIN_ATTEMPT, PERMISSION_DENIED, DATA_EXPORT, etc.
  resource  String? // Resource being accessed
  result    String // SUCCESS, FAILURE
  ipAddress String?
  userAgent String?
  requestId String?
  metadata  Json?    @db.JsonB
  timestamp DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([action])
  @@index([timestamp])
  @@index([ipAddress])
  @@index([result])
}

model AlertLog {
  id       String   @id @default(cuid())
  severity String // LOW, MEDIUM, HIGH, CRITICAL
  title    String
  message  String
  details  Json?    @db.JsonB
  sentAt   DateTime @default(now()) @db.Timestamptz

  @@index([severity])
  @@index([sentAt])
}
